---

title: 面经1
date: 2025-04-20 14:10:33

---

### tips：

1. **突出基础:** 扎实的计算机科学基础（数据结构、算法、操作系统、网络）是根本。
2. **结合项目:** 将上述知识点与你做过的项目经验结合起来谈，说明你在实际中是如何考虑和解决这些问题的。即使不是支付项目，也可以将在高并发、高可用、数据一致性方面的经验迁移过来。
3. **强调思考过程:** 不仅要说出用了什么技术，更要说明 *为什么* 用这个技术，以及考虑了哪些 *权衡 (Trade-offs)*。
4. **展现对质量的关注:** 强调你对代码质量、测试、系统稳定性和安全性的重视。
5. **准备提问:** 准备一些有深度的问题问面试官，比如他们目前支付系统面临的最大挑战、技术选型、团队文化等。

# 线程池

## 1. 为什么需要线程池

在介绍线程池之前，我们先理解为什么需要线程池：

- **降低资源消耗**：通过重用已存在的线程，减少线程创建和销毁的开销
- **提高响应速度**：任务到达时，可以不必等待线程创建就能立即执行
- **提高线程的可管理性**：线程是稀缺资源，使用线程池可以统一管理，调度，监控

## 2. 线程池的核心原理

Java 中的线程池主要由 `ThreadPoolExecutor` 类实现，其核心工作原理如下：

1. **线程池管理**：线程池维护着一定数量的线程，并且这些线程的生命周期由线程池控制
2. **任务队列**：当所有线程都在忙碌时，新提交的任务会被放入队列中等待执行
3. **任务执行**：线程池中的线程会不断从任务队列中取出任务并执行

### 核心参数

`ThreadPoolExecutor` 的构造函数接受以下几个重要参数：

- **corePoolSize**：线程池中保持的核心线程数，即使线程空闲也不会被销毁（除非设置 allowCoreThreadTimeOut）
- **maximumPoolSize**：线程池允许创建的最大线程数
- **keepAliveTime**：超出核心线程数的空闲线程，在空闲时间超过这个值后会被回收
- **workQueue**：存放待执行任务的队列
- **threadFactory**：创建新线程的工厂
- **handler**：当线程池和队列都满了，无法接受新任务时的处理策略

使用默认拒绝策略，IO密集型任务线程池为核心线程数的三倍。

## 最佳实践与注意事项

### 1. 避免使用 Executors 创建线程池

推荐直接使用 `ThreadPoolExecutor` 构造方法创建线程池，明确指定各个参数。

### 2. 使用有界队列

尽量使用有界队列，如 `ArrayBlockingQueue`，避免队列无限增长导致 OOM。

### 3. 异常处理

线程池中的任务抛出未捕获的异常不会导致线程池停止，但会导致线程退出并可能创建新线程。建议在任务内部进行异常捕获和处理.

## Java 8 以后的增强

Java 8 引入了 `CompletableFuture`，提供了更强大的异步编程模型，它底层默认使用 `ForkJoinPool`。

# 互斥锁

### 原子指令

## 自旋锁(Spinlock)

## 4. 编程语言中的互斥锁实现

### 4.1 Java中的互斥锁

Java的synchronized关键字实现：

- 基于对象的监视器锁(Monitor)
- 结合了偏向锁、轻量级锁和重量级锁的多级实现

JVM中的锁升级过程：

1. **偏向锁**：无竞争情况下，标记锁对象为第一个获取线程所拥有

2. **轻量级锁**：有竞争但不激烈时，使用CAS操作在用户空间自旋

3. **重量级锁**：竞争激烈时，使用操作系统提供的互斥量，让线程休眠等待

4. ## 互斥锁实现的关键特性
   
   ### 5.1 可重入性(Reentrant)
   
   - 允许同一线程多次获取同一锁
   - 通过记录锁持有者和加锁计数实现
   
   ### 5.2 公平性(Fairness)
   
   - 公平锁：按照请求顺序分配锁，防止饥饿
   - 非公平锁：允许新来的线程"插队"获取锁，提高吞吐量
   
   ### 5.3 死锁预防
   
   - 超时机制：允许在指定时间内未获取到锁时返回
   - 锁排序：保证多个锁按照相同的顺序获取
   - 锁层级：为锁分配层级，只允许按照层级顺序获取

## 总结

互斥锁的实现涉及多个层次：

1. 硬件层：原子指令提供基础保障
2. 操作系统层：结合自旋和线程调度实现高效互斥
3. 语言层：在操作系统基础上提供更易用的抽象

互斥锁的设计需要平衡多个因素：

- 性能（锁的获取和释放速度）
- 公平性（防止线程饥饿）
- 资源使用（CPU时间、内存占用）
- 复杂性（实现难度和使用便捷性）

现代互斥锁通常采用多级实现策略，根据竞争情况动态调整，以在不同场景下获得最优性能。

锁不可重入会因自指导致死锁

# 高并发高可用

## 解决方案对比

| 方面   | 高并发解决方案     | 高可用解决方案     |
| ---- | ----------- | ----------- |
| 架构层面 | 微服务拆分、无状态设计 | 服务冗余、故障隔离   |
| 计算资源 | 集群扩展、弹性伸缩   | 主备架构、自动故障转移 |
| 数据层  | 分库分表、缓存加速   | 数据多副本、备份恢复  |
| 网络层  | 负载均衡、流量分发   | 多链路保障、故障重路由 |
| 应用层  | 代码优化、异步调用   | 优雅降级、限流熔断   |
